// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function batch(cmds) {
  return {
          TAG: "Batch",
          _0: cmds
        };
}

function perform(task, toMsg) {
  return {
          TAG: "Perform",
          _0: (async function () {
              return toMsg(await task());
            })
        };
}

function attempt(task, toMsg) {
  return {
          TAG: "Perform",
          _0: (async function () {
              try {
                return toMsg({
                            TAG: "Ok",
                            _0: await task()
                          });
              }
              catch (raw_exn){
                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                return toMsg({
                            TAG: "Error",
                            _0: exn
                          });
              }
            })
        };
}

function withDispatch(fn) {
  return {
          TAG: "PerformWithDispatch",
          _0: fn
        };
}

var Cmd = {
  none: "None",
  batch: batch,
  perform: perform,
  attempt: attempt,
  withDispatch: withDispatch
};

function batch$1(subs) {
  return {
          TAG: "Batch",
          _0: subs
        };
}

function httpServer(port, handler) {
  return {
          TAG: "HttpServer",
          _0: port,
          _1: handler
        };
}

function every(ms, toMsg) {
  return {
          TAG: "Interval",
          _0: ms,
          _1: toMsg
        };
}

var Sub = {
  none: "None",
  batch: batch$1,
  httpServer: httpServer,
  every: every
};

async function executeCmd(cmd, dispatch) {
  if (typeof cmd !== "object") {
    return ;
  }
  switch (cmd.TAG) {
    case "Batch" :
        cmd._0.forEach(function (c) {
              executeCmd(c, dispatch);
            });
        return ;
    case "Perform" :
        var msg = await cmd._0();
        return dispatch(msg);
    case "PerformWithDispatch" :
        return await cmd._0(dispatch);
    
  }
}

function make(init, update, subscriptions, flags) {
  var match = init(flags);
  var state = {
    model: match[0],
    subscriptions: [],
    running: true,
    httpServer: undefined,
    intervals: []
  };
  var dispatch = function (msg) {
    if (!state.running) {
      return ;
    }
    var match = update(msg, state.model);
    state.model = match[0];
    executeCmd(match[1], dispatch);
    updateSubscriptions();
  };
  var updateSubscriptions = function () {
    var newSubs = subscriptions(state.model);
    state.subscriptions = [newSubs];
  };
  var startSubscription = function (sub) {
    if (typeof sub !== "object") {
      return ;
    }
    switch (sub.TAG) {
      case "Batch" :
          sub._0.forEach(startSubscription);
          return ;
      case "HttpServer" :
          var handler = sub._1;
          var server = Deno.serve({
                port: sub._0
              }, (async function (req) {
                  var body = await req.text();
                  var json;
                  try {
                    json = JSON.parse(body);
                  }
                  catch (exn){
                    json = undefined;
                  }
                  var msg = Belt_Option.flatMap(json, handler);
                  if (msg !== undefined) {
                    dispatch(Caml_option.valFromOption(msg));
                    return new (globalThis.Response)("OK", {
                                status: 200
                              });
                  } else {
                    return new (globalThis.Response)("Ignored", {
                                status: 200
                              });
                  }
                }));
          state.httpServer = Caml_option.some(server);
          return ;
      case "Interval" :
          var toMsg = sub._1;
          var id = setInterval((function () {
                  dispatch(toMsg());
                }), sub._0);
          state.intervals = state.intervals.concat([id]);
          return ;
      
    }
  };
  executeCmd(match[1], dispatch);
  var initialSubs = subscriptions(state.model);
  startSubscription(initialSubs);
  return {
          dispatch: dispatch,
          getModel: (function () {
              return state.model;
            }),
          stop: (function () {
              state.running = false;
              Belt_Option.forEach(state.httpServer, (function (server) {
                      server.shutdown();
                    }));
              state.intervals.forEach(function (prim) {
                    clearInterval(prim);
                  });
            })
        };
}

var Runtime = {
  executeCmd: executeCmd,
  make: make
};

export {
  Cmd ,
  Sub ,
  Runtime ,
}
/* No side effect */
