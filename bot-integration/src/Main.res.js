// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Config from "./Config.res.js";
import * as Report from "./Report.res.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Webhook from "./Webhook.res.js";
import * as Analysis from "./Analysis.res.js";
import * as GitHubAPI from "./GitHubAPI.res.js";
import * as GitHubApp from "./GitHubApp.res.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function log(level, msg, data) {
  var timestamp = new Date().toISOString();
  var logObj = data !== undefined ? Js_dict.fromArray([
          [
            "timestamp",
            timestamp
          ],
          [
            "level",
            level
          ],
          [
            "message",
            msg
          ],
          [
            "data",
            data
          ]
        ]) : Js_dict.fromArray([
          [
            "timestamp",
            timestamp
          ],
          [
            "level",
            level
          ],
          [
            "message",
            msg
          ]
        ]);
  console.log(JSON.stringify(logObj));
}

function info(msg, data) {
  log("info", msg, data);
}

function error(msg, data) {
  log("error", msg, data);
}

function extractPRInfo(payload) {
  var obj = Js_json.decodeObject(payload);
  if (obj === undefined) {
    return [
            0,
            "",
            ""
          ];
  }
  var n = Js_dict.get(obj, "number");
  var prNumber;
  if (n !== undefined) {
    var num = Js_json.decodeNumber(n);
    prNumber = num !== undefined ? num | 0 : 0;
  } else {
    prNumber = 0;
  }
  var pr = Js_dict.get(obj, "pull_request");
  var match;
  if (pr !== undefined) {
    var prObj = Js_json.decodeObject(pr);
    if (prObj !== undefined) {
      var b = Js_dict.get(prObj, "base");
      var base;
      if (b !== undefined) {
        var baseObj = Js_json.decodeObject(b);
        if (baseObj !== undefined) {
          var s = Js_dict.get(baseObj, "sha");
          base = s !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(s), "") : "";
        } else {
          base = "";
        }
      } else {
        base = "";
      }
      var h = Js_dict.get(prObj, "head");
      var head;
      if (h !== undefined) {
        var headObj = Js_json.decodeObject(h);
        if (headObj !== undefined) {
          var s$1 = Js_dict.get(headObj, "sha");
          head = s$1 !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(s$1), "") : "";
        } else {
          head = "";
        }
      } else {
        head = "";
      }
      match = [
        base,
        head
      ];
    } else {
      match = [
        "",
        ""
      ];
    }
  } else {
    match = [
      "",
      ""
    ];
  }
  return [
          prNumber,
          match[0],
          match[1]
        ];
}

function extractMRInfo(payload) {
  var obj = Js_json.decodeObject(payload);
  if (obj === undefined) {
    return [
            0,
            "",
            ""
          ];
  }
  var attrs = Js_dict.get(obj, "object_attributes");
  if (attrs === undefined) {
    return [
            0,
            "",
            ""
          ];
  }
  var attrsObj = Js_json.decodeObject(attrs);
  if (attrsObj === undefined) {
    return [
            0,
            "",
            ""
          ];
  }
  var n = Js_dict.get(attrsObj, "iid");
  var mrIid;
  if (n !== undefined) {
    var num = Js_json.decodeNumber(n);
    mrIid = num !== undefined ? num | 0 : 0;
  } else {
    mrIid = 0;
  }
  var refs = Js_dict.get(attrsObj, "diff_refs");
  var baseSha;
  if (refs !== undefined) {
    var refsObj = Js_json.decodeObject(refs);
    if (refsObj !== undefined) {
      var s = Js_dict.get(refsObj, "base_sha");
      baseSha = s !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(s), "") : "";
    } else {
      baseSha = "";
    }
  } else {
    baseSha = "";
  }
  var commit = Js_dict.get(attrsObj, "last_commit");
  var headSha;
  if (commit !== undefined) {
    var commitObj = Js_json.decodeObject(commit);
    if (commitObj !== undefined) {
      var s$1 = Js_dict.get(commitObj, "id");
      headSha = s$1 !== undefined ? Belt_Option.getWithDefault(Js_json.decodeString(s$1), "") : "";
    } else {
      headSha = "";
    }
  } else {
    headSha = "";
  }
  return [
          mrIid,
          baseSha,
          headSha
        ];
}

function jsonResponse(data, statusOpt) {
  var status = statusOpt !== undefined ? statusOpt : 200;
  return new (globalThis.Response)(JSON.stringify(data), {
              status: status,
              headers: {
                "Content-Type": "application/json"
              }
            });
}

async function validateGitHubSignature(config, headers, body) {
  var secret = config.githubWebhookSecret;
  if (secret === undefined) {
    return ;
  }
  var signature = Belt_Option.getWithDefault(Js_dict.get(headers, "x-hub-signature-256"), "");
  var valid = await Webhook.verifyGitHubSignature(body, signature, secret);
  if (!valid) {
    error("Invalid GitHub webhook signature", undefined);
    return Caml_option.some(new (globalThis.Response)("{\"error\": \"Invalid signature\"}", {
                    status: 401
                  }));
  }
  
}

async function handleGitHubWebhook(config, headers, body) {
  var signatureError = await validateGitHubSignature(config, headers, body);
  if (signatureError !== undefined) {
    return Caml_option.valFromOption(signatureError);
  }
  var parseResult;
  try {
    parseResult = JSON.parse(body);
  }
  catch (exn){
    parseResult = undefined;
  }
  if (parseResult === undefined) {
    return new (globalThis.Response)("{\"error\": \"Invalid JSON\"}", {
                status: 400
              });
  }
  var $$event = Webhook.parseGitHubEvent(headers, parseResult);
  if ($$event !== undefined) {
    info("GitHub event: " + $$event.eventType, Js_dict.fromArray([
              [
                "repo",
                $$event.repository.owner + "/" + $$event.repository.name
              ],
              [
                "action",
                Belt_Option.getWithDefault($$event.action, "")
              ]
            ]));
    if ($$event.eventType === "pull_request") {
      var action = Belt_Option.getWithDefault($$event.action, "");
      if (action === "opened" || action === "synchronize") {
        var match = extractPRInfo(parseResult);
        var prNumber = match[0];
        var analysisResult = await Analysis.analyzeDiff(config.analysisEndpoint, $$event.repository.url, match[1], match[2]);
        var comment;
        if (analysisResult.TAG === "Ok") {
          comment = Report.generatePRComment(analysisResult._0, config.mode);
        } else {
          error("Analysis failed: " + analysisResult._0, undefined);
          var analysis = Analysis.mockAnalysis();
          comment = Report.generatePRComment(analysis, config.mode);
        }
        var authResult = await GitHubApp.getAuthToken(config, parseResult);
        if (authResult.TAG === "Ok") {
          var postResult = await GitHubAPI.postPRComment(authResult._0, $$event.repository.owner, $$event.repository.name, prNumber, comment);
          if (postResult.TAG === "Ok") {
            info("Posted PR comment", Js_dict.fromArray([
                      [
                        "pr",
                        prNumber
                      ],
                      [
                        "commentId",
                        postResult._0
                      ]
                    ]));
          } else {
            error("Failed to post PR comment: " + postResult._0, undefined);
          }
        } else {
          info("GitHub App not configured, comment not posted: " + authResult._0, comment);
        }
      }
      
    }
    return jsonResponse(Js_dict.fromArray([[
                      "status",
                      "processed"
                    ]]), undefined);
  }
  error("Failed to parse GitHub event", undefined);
  return new (globalThis.Response)("{\"error\": \"Invalid event\"}", {
              status: 400
            });
}

function validateGitLabToken(config, headers) {
  var secret = config.gitlabWebhookSecret;
  if (secret === undefined) {
    return ;
  }
  var token = Belt_Option.getWithDefault(Js_dict.get(headers, "x-gitlab-token"), "");
  if (!Webhook.verifyGitLabToken(token, secret)) {
    error("Invalid GitLab webhook token", undefined);
    return Caml_option.some(new (globalThis.Response)("{\"error\": \"Invalid token\"}", {
                    status: 401
                  }));
  }
  
}

async function handleGitLabWebhook(config, headers, body) {
  var tokenError = validateGitLabToken(config, headers);
  if (tokenError !== undefined) {
    return Caml_option.valFromOption(tokenError);
  }
  var parseResult;
  try {
    parseResult = JSON.parse(body);
  }
  catch (exn){
    parseResult = undefined;
  }
  if (parseResult === undefined) {
    return new (globalThis.Response)("{\"error\": \"Invalid JSON\"}", {
                status: 400
              });
  }
  var $$event = Webhook.parseGitLabEvent(headers, parseResult);
  if ($$event !== undefined) {
    info("GitLab event: " + $$event.eventType, Js_dict.fromArray([[
                "repo",
                $$event.repository.owner + "/" + $$event.repository.name
              ]]));
    if ($$event.eventType === "Merge Request Hook") {
      var match = extractMRInfo(parseResult);
      var analysisResult = await Analysis.analyzeDiff(config.analysisEndpoint, $$event.repository.url, match[1], match[2]);
      if (analysisResult.TAG === "Ok") {
        var comment = Report.generatePRComment(analysisResult._0, config.mode);
        info("Generated MR comment for MR !" + String(match[0]), comment);
      } else {
        error("Analysis failed: " + analysisResult._0, undefined);
        var analysis = Analysis.mockAnalysis();
        var comment$1 = Report.generatePRComment(analysis, config.mode);
        info("Generated fallback MR comment", comment$1);
      }
    }
    return jsonResponse(Js_dict.fromArray([[
                      "status",
                      "processed"
                    ]]), undefined);
  }
  error("Failed to parse GitLab event", undefined);
  return new (globalThis.Response)("{\"error\": \"Invalid event\"}", {
              status: 400
            });
}

function handler(config) {
  return async function (req, _connInfo) {
    var url = req.url;
    var method = req.method;
    var path = url.replace(/^https?:\/\/[^\/]+/, "");
    switch (method) {
      case "GET" :
          switch (path) {
            case "/health" :
                return jsonResponse(Js_dict.fromArray([
                                [
                                  "status",
                                  "healthy"
                                ],
                                [
                                  "mode",
                                  Config.modeToString(config.mode)
                                ]
                              ]), undefined);
            case "/metrics" :
                return jsonResponse(Js_dict.fromArray([
                                [
                                  "oikos_bot_requests_total",
                                  0.0
                                ],
                                [
                                  "oikos_bot_analyses_total",
                                  0.0
                                ]
                              ]), undefined);
            default:
              return new (globalThis.Response)("Not Found", {
                          status: 404
                        });
          }
      case "POST" :
          switch (path) {
            case "/webhooks/github" :
                var body = await req.text();
                var headers = req.headers;
                return await handleGitHubWebhook(config, headers, body);
            case "/webhooks/gitlab" :
                var body$1 = await req.text();
                var headers$1 = req.headers;
                return await handleGitLabWebhook(config, headers$1, body$1);
            default:
              return new (globalThis.Response)("Not Found", {
                          status: 404
                        });
          }
      default:
        return new (globalThis.Response)("Not Found", {
                    status: 404
                  });
    }
  };
}

function main() {
  var config = Config.load();
  if (config.TAG !== "Ok") {
    return error("Failed to load config: " + config._0, undefined);
  }
  var config$1 = config._0;
  info("Starting Oikos Bot", Js_dict.fromArray([
            [
              "port",
              config$1.port
            ],
            [
              "mode",
              Config.modeToString(config$1.mode)
            ]
          ]));
  Deno.serve({
        port: config$1.port,
        onListen: (function (param) {
            info("Server listening on " + param.hostname + ":" + String(param.port), undefined);
          })
      }, handler(config$1));
}

main();

export {
  log ,
  info ,
  error ,
  extractPRInfo ,
  extractMRInfo ,
  jsonResponse ,
  validateGitHubSignature ,
  handleGitHubWebhook ,
  validateGitLabToken ,
  handleGitLabWebhook ,
  handler ,
  main ,
}
/*  Not a pure module */
