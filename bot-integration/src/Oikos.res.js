// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as ServerTea from "./tea/ServerTea.res.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function modeFromString(str) {
  switch (str) {
    case "consultant" :
        return "Consultant";
    case "regulator" :
        return "Regulator";
    default:
      return "Advisor";
  }
}

function init(flags) {
  var model_mode = modeFromString(flags.mode);
  var model_port = flags.port;
  var model_webhookSecret = flags.webhookSecret;
  var model_appId = flags.appId;
  var model_privateKeyPath = flags.privateKeyPath;
  var model_pendingAnalyses = [];
  var model_startTime = Date.now();
  var model = {
    mode: model_mode,
    port: model_port,
    webhookSecret: model_webhookSecret,
    appId: model_appId,
    privateKeyPath: model_privateKeyPath,
    pendingAnalyses: model_pendingAnalyses,
    totalProcessed: 0,
    startTime: model_startTime,
    healthy: true
  };
  console.log("üèõÔ∏è Oikos Bot starting...");
  console.log("   Mode: " + flags.mode);
  console.log("   Port: " + String(flags.port));
  return [
          model,
          ServerTea.Cmd.none
        ];
}

function update(msg, model) {
  if (typeof msg !== "object") {
    switch (msg) {
      case "HealthCheck" :
          console.log("üíö Health check - processed: " + String(model.totalProcessed));
          return [
                  model,
                  ServerTea.Cmd.none
                ];
      case "Tick" :
          var now = Date.now();
          var oneHour = 60.0 * 60.0 * 1000.0;
          var pendingAnalyses = model.pendingAnalyses.filter(function (a) {
                return now - a.createdAt < oneHour;
              });
          return [
                  {
                    mode: model.mode,
                    port: model.port,
                    webhookSecret: model.webhookSecret,
                    appId: model.appId,
                    privateKeyPath: model.privateKeyPath,
                    pendingAnalyses: pendingAnalyses,
                    totalProcessed: model.totalProcessed,
                    startTime: model.startTime,
                    healthy: model.healthy
                  },
                  ServerTea.Cmd.none
                ];
      case "Shutdown" :
          console.log("üëã Shutting down...");
          return [
                  {
                    mode: model.mode,
                    port: model.port,
                    webhookSecret: model.webhookSecret,
                    appId: model.appId,
                    privateKeyPath: model.privateKeyPath,
                    pendingAnalyses: model.pendingAnalyses,
                    totalProcessed: model.totalProcessed,
                    startTime: model.startTime,
                    healthy: false
                  },
                  ServerTea.Cmd.none
                ];
      
    }
  } else {
    switch (msg.TAG) {
      case "WebhookReceived" :
          var payload = msg._1;
          var source = msg._0;
          var sourceStr;
          sourceStr = source === "GitHub" ? "GitHub" : "GitLab";
          console.log("üì® Webhook received from " + sourceStr);
          return [
                  model,
                  ServerTea.Cmd.perform((async function () {
                          return payload;
                        }), (function (p) {
                          return {
                                  TAG: "WebhookVerified",
                                  _0: source,
                                  _1: p
                                };
                        }))
                ];
      case "WebhookVerified" :
          console.log("‚úì Webhook verified");
          return [
                  {
                    mode: model.mode,
                    port: model.port,
                    webhookSecret: model.webhookSecret,
                    appId: model.appId,
                    privateKeyPath: model.privateKeyPath,
                    pendingAnalyses: model.pendingAnalyses,
                    totalProcessed: model.totalProcessed + 1 | 0,
                    startTime: model.startTime,
                    healthy: model.healthy
                  },
                  ServerTea.Cmd.none
                ];
      case "WebhookRejected" :
          console.error("‚úó Webhook rejected: " + msg._0);
          return [
                  model,
                  ServerTea.Cmd.none
                ];
      case "AnalysisRequested" :
          var prNumber = msg._2;
          var repo = msg._1;
          console.log("üîç Analysis requested: " + repo + "#" + String(prNumber));
          var analysis_id = msg._0;
          var analysis_createdAt = Date.now();
          var analysis = {
            id: analysis_id,
            repo: repo,
            prNumber: prNumber,
            status: "Pending",
            createdAt: analysis_createdAt
          };
          return [
                  {
                    mode: model.mode,
                    port: model.port,
                    webhookSecret: model.webhookSecret,
                    appId: model.appId,
                    privateKeyPath: model.privateKeyPath,
                    pendingAnalyses: model.pendingAnalyses.concat([analysis]),
                    totalProcessed: model.totalProcessed,
                    startTime: model.startTime,
                    healthy: model.healthy
                  },
                  ServerTea.Cmd.none
                ];
      case "AnalysisStarted" :
          var id = msg._0;
          var pendingAnalyses$1 = model.pendingAnalyses.map(function (a) {
                if (a.id === id) {
                  return {
                          id: a.id,
                          repo: a.repo,
                          prNumber: a.prNumber,
                          status: "InProgress",
                          createdAt: a.createdAt
                        };
                } else {
                  return a;
                }
              });
          return [
                  {
                    mode: model.mode,
                    port: model.port,
                    webhookSecret: model.webhookSecret,
                    appId: model.appId,
                    privateKeyPath: model.privateKeyPath,
                    pendingAnalyses: pendingAnalyses$1,
                    totalProcessed: model.totalProcessed,
                    startTime: model.startTime,
                    healthy: model.healthy
                  },
                  ServerTea.Cmd.none
                ];
      case "AnalysisCompleted" :
          var result = msg._1;
          var id$1 = msg._0;
          console.log("‚úì Analysis completed: " + id$1);
          var pendingAnalyses$2 = model.pendingAnalyses.map(function (a) {
                if (a.id === id$1) {
                  return {
                          id: a.id,
                          repo: a.repo,
                          prNumber: a.prNumber,
                          status: {
                            TAG: "Completed",
                            _0: result
                          },
                          createdAt: a.createdAt
                        };
                } else {
                  return a;
                }
              });
          return [
                  {
                    mode: model.mode,
                    port: model.port,
                    webhookSecret: model.webhookSecret,
                    appId: model.appId,
                    privateKeyPath: model.privateKeyPath,
                    pendingAnalyses: pendingAnalyses$2,
                    totalProcessed: model.totalProcessed,
                    startTime: model.startTime,
                    healthy: model.healthy
                  },
                  ServerTea.Cmd.none
                ];
      case "AnalysisFailed" :
          var error = msg._1;
          var id$2 = msg._0;
          console.error("‚úó Analysis failed: " + id$2 + " - " + error);
          var pendingAnalyses$3 = model.pendingAnalyses.map(function (a) {
                if (a.id === id$2) {
                  return {
                          id: a.id,
                          repo: a.repo,
                          prNumber: a.prNumber,
                          status: {
                            TAG: "Failed",
                            _0: error
                          },
                          createdAt: a.createdAt
                        };
                } else {
                  return a;
                }
              });
          return [
                  {
                    mode: model.mode,
                    port: model.port,
                    webhookSecret: model.webhookSecret,
                    appId: model.appId,
                    privateKeyPath: model.privateKeyPath,
                    pendingAnalyses: pendingAnalyses$3,
                    totalProcessed: model.totalProcessed,
                    startTime: model.startTime,
                    healthy: model.healthy
                  },
                  ServerTea.Cmd.none
                ];
      case "CommentPosted" :
          console.log("üí¨ Comment posted to " + msg._0 + "#" + String(msg._1));
          return [
                  model,
                  ServerTea.Cmd.none
                ];
      case "CommentFailed" :
          console.error("‚úó Failed to post comment to " + msg._0 + ": " + msg._1);
          return [
                  model,
                  ServerTea.Cmd.none
                ];
      
    }
  }
}

function subscriptions(model) {
  if (model.healthy) {
    return ServerTea.Sub.batch([
                ServerTea.Sub.httpServer(model.port, (function (json) {
                        return {
                                TAG: "WebhookReceived",
                                _0: "GitHub",
                                _1: json
                              };
                      })),
                ServerTea.Sub.every(60000, (function () {
                        return "Tick";
                      }))
              ]);
  } else {
    return ServerTea.Sub.none;
  }
}

function run() {
  var p = Deno.env.get("PORT");
  var port = p !== undefined ? Belt_Option.getWithDefault(Belt_Int.fromString(p), 3000) : 3000;
  var mode = Belt_Option.getWithDefault(Deno.env.get("BOT_MODE"), "advisor");
  var webhookSecret = Deno.env.get("GITHUB_WEBHOOK_SECRET");
  var appId = Deno.env.get("GITHUB_APP_ID");
  var privateKeyPath = Deno.env.get("GITHUB_PRIVATE_KEY_PATH");
  var flags = {
    port: port,
    mode: mode,
    webhookSecret: webhookSecret,
    appId: appId,
    privateKeyPath: privateKeyPath
  };
  return ServerTea.Runtime.make(init, update, subscriptions, flags);
}

run();

export {
  modeFromString ,
  init ,
  update ,
  subscriptions ,
  run ,
}
/*  Not a pure module */
